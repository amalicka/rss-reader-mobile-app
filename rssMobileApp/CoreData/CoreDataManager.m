//
//  CoreDataManager.m
//  rssMobileApp
//
//  Created by amalicka on 14.02.2016.
//  Copyright © 2016 amalicka. All rights reserved.
//

#import "CoreDataManager.h"
#import "SyncSessionManager.h"
#import "ApiClient.h"
#import "Parser.h"
#import "StringConstans.h"

static NSString *hFeed = @"Feed";
static NSString *hPost = @"Post";

@implementation CoreDataManager

#pragma mark - Core Data stack

@synthesize managedObjectContext = _managedObjectContext;
@synthesize managedObjectModel = _managedObjectModel;
@synthesize persistentStoreCoordinator = _persistentStoreCoordinator;

+(instancetype)sharedManager{
    static CoreDataManager *instance;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        instance = [[CoreDataManager alloc] init];
    });
    return instance;
}

#pragma mark CoreData autogenerated

- (NSURL *)applicationDocumentsDirectory {
    // The directory the application uses to store the Core Data store file. This code uses a directory named "AS.rssMobileApp" in the application's documents directory.
    return [[[NSFileManager defaultManager] URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask] lastObject];
}

- (NSManagedObjectModel *)managedObjectModel {
    // The managed object model for the application. It is a fatal error for the application not to be able to find and load its model.
    if (_managedObjectModel != nil) {
        return _managedObjectModel;
    }
    //TODO why modelUrl is nil?
    //NSURL *modelURL = [[NSBundle mainBundle] URLForResource:@"rssMobileApp" withExtension:@"momd"];
    //_managedObjectModel = [[NSManagedObjectModel alloc] initWithContentsOfURL:modelURL];
    NSString *modelPath = [[NSBundle mainBundle] pathForResource:@"rssMobileApp" ofType:@"momd"];
    _managedObjectModel = [[NSManagedObjectModel alloc] initWithContentsOfURL:[NSURL fileURLWithPath:modelPath]];
    return _managedObjectModel;
}

- (NSPersistentStoreCoordinator *)persistentStoreCoordinator {
    // The persistent store coordinator for the application. This implementation creates and returns a coordinator, having added the store for the application to it.
    if (_persistentStoreCoordinator != nil) {
        return _persistentStoreCoordinator;
    }
    
    // Create the coordinator and store
    
    _persistentStoreCoordinator = [[NSPersistentStoreCoordinator alloc] initWithManagedObjectModel:[self managedObjectModel]];
    NSURL *storeURL = [[self applicationDocumentsDirectory] URLByAppendingPathComponent:@"rssMobileApp.sqlite"];
    NSError *error = nil;
    NSString *failureReason = @"There was an error creating or loading the application's saved data.";
    if (![_persistentStoreCoordinator addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:storeURL options:nil error:&error]) {
        // Report any error we got.
        NSMutableDictionary *dict = [NSMutableDictionary dictionary];
        dict[NSLocalizedDescriptionKey] = @"Failed to initialize the application's saved data";
        dict[NSLocalizedFailureReasonErrorKey] = failureReason;
        dict[NSUnderlyingErrorKey] = error;
        error = [NSError errorWithDomain:@"YOUR_ERROR_DOMAIN" code:9999 userInfo:dict];
        // Replace this with code to handle the error appropriately.
        // abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.
        NSLog(@"CORE DATA MANAGER Unresolved error %@, %@", error, [error userInfo]);
        abort();
    }
    
    return _persistentStoreCoordinator;
}

- (NSManagedObjectContext *)managedObjectContext {
    // Returns the managed object context for the application (which is already bound to the persistent store coordinator for the application.)
    if (_managedObjectContext != nil) {
        return _managedObjectContext;
    }
    
    NSPersistentStoreCoordinator *coordinator = [self persistentStoreCoordinator];
    if (!coordinator) {
        return nil;
    }
    _managedObjectContext = [[NSManagedObjectContext alloc] initWithConcurrencyType:NSMainQueueConcurrencyType];
    [_managedObjectContext setPersistentStoreCoordinator:coordinator];
    return _managedObjectContext;
}

#pragma mark - Core Data Saving support

- (void)saveContext {
    NSManagedObjectContext *managedObjectContext = self.managedObjectContext;
    if (managedObjectContext != nil) {
        NSError *error = nil;
        if ([managedObjectContext hasChanges] && ![managedObjectContext save:&error]) {
            // Replace this implementation with code to handle the error appropriately.
            // abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.
            NSLog(@"CORE DATA MANAGER Unresolved error %@, %@", error, [error userInfo]);
            abort();
        }
    }
}

#pragma mark - Data methods

- (SaveFeedStatus)saveFeed:(NSString *)feedUrl{
    NSManagedObjectContext *context = [self managedObjectContext];
    NSPredicate *p = [NSPredicate predicateWithFormat:@"SELF.url == [c] %@", feedUrl];
    NSArray *array = [self getCoreDataObjectsWithEntityName:hFeed andPredicate: p];
    
    Feed *tmpFeed;
    if(array!=nil){
        Feed *feed = (Feed*)array[0];
        if([feed.is_deleted isEqual:[NSNumber numberWithBool:NO]]){
            return kAlreadyPresent;
        }else{
            feed.is_deleted = [NSNumber numberWithBool:NO];
            feed.sync_timestamp = [NSNumber numberWithDouble:([SyncSessionManager getLastSyncTime] +1)];
            for(Post *p in feed.posts){
                p.is_read = [NSNumber numberWithBool:NO];
                p.is_fav = [NSNumber numberWithBool:NO];
            }
        }
        tmpFeed = feed;
    }
    else{
        Feed *feed = [[Feed alloc] initWithEntity:[NSEntityDescription entityForName:hFeed inManagedObjectContext:context] insertIntoManagedObjectContext:context];
        feed.url = [feedUrl lowercaseString];
        feed.is_deleted = [NSNumber numberWithBool:NO];
        feed.sync_timestamp = [NSNumber numberWithDouble:([SyncSessionManager getLastSyncTime] +1)];
        NSString *str = [NSString stringWithFormat:@"http://www.google.com/s2/favicons?domain=%@", feed.url];
        NSString *strFav = [str stringByReplacingOccurrencesOfString:@"/feed" withString:@""];
        feed.favicon = [NSData dataWithContentsOfURL:[NSURL URLWithString:strFav]];
        tmpFeed = feed;
    }
    
    //SAVE CHANGES
    NSError *error = nil;
    if([context save:&error]){
        //LOAD POSTS
        [[ApiClient sharedSingleton] getDataForFeed: tmpFeed.url withSuccess:^(AFHTTPRequestOperation *operation, id responseObject) {
            [Parser parseData:responseObject forFeed:tmpFeed];
             NSLog(@"Parsing data for newly added single feed");
        } failure:^(NSError *error) {
            [[NSNotificationCenter defaultCenter] postNotificationName:notifFeedUpdated object:@"gettingDataForFeedFailed"];
            NSLog(@"Getting data for feed postsfailed - CORE DATA");
        }];
        NSLog(@"CORE DATA MANAGER feed saved to database");
        return kFeedSaved;
    }else{
        NSLog(@"CORE DATA MANAGER feed saving error:%@",error);
        return kSavingError;
    }
}

- (void)addFeeds:(NSArray*)feeds{
    NSManagedObjectContext *context = [self managedObjectContext];
    for(NSDictionary* feedDictionary in feeds){
        Feed *feed = [[Feed alloc] initWithEntity:[NSEntityDescription entityForName:hFeed inManagedObjectContext:context] insertIntoManagedObjectContext:context];
        [feed updateWithDictionary:feedDictionary];
        
        //TODO: feed.is_deletet ?
    }
    NSError *error = nil;
    if([context save:&error]){
        //ok
    }else{
        NSLog(@"CORE DATA MANAGER feed saving error:%@",error);
    }
}

- (NSArray *)getAllFeeds{
    return [self getCoreDataObjectsWithEntityName:hFeed andPredicate:nil];
}

- (NSArray *)getAllActiveFeeds{
    NSPredicate *predicate = [NSPredicate predicateWithFormat:@"SELF.is_deleted ==NO"];
    NSArray *array = [[NSArray alloc]init];
    array = [self getCoreDataObjectsWithEntityName:hFeed andPredicate:predicate];
    return (array)? array : ([[NSArray alloc]init]);
}

- (NSArray*)getAllFeedsFromTimestamp:(double)timestamp{
    NSPredicate *predicate = [NSPredicate predicateWithFormat:@"SELF.sync_timestamp >= %f",timestamp];
    NSArray *feeds = [self getCoreDataObjectsWithEntityName:hFeed andPredicate:predicate];
    return (feeds)? feeds : ([[NSArray alloc]init]);
}

- (NSArray*)getAllDeletedFeedsFromLastSync{
    NSNumber *timestamp = [NSNumber numberWithDouble:[SyncSessionManager getLastSyncTime]];
    NSPredicate *predicate = [NSPredicate predicateWithFormat:@"SELF.sync_timestamp >= %f AND SELF.is_deleted ==YES",timestamp];
    NSArray *feeds = [self getCoreDataObjectsWithEntityName:hFeed andPredicate:predicate];
    return (feeds)? feeds : ([[NSArray alloc]init]);
}

- (NSArray*)getAllAddedFeedsFromLastSync{
    NSNumber *timestamp = [NSNumber numberWithDouble:[SyncSessionManager getLastSyncTime]];
    NSPredicate *predicate = [NSPredicate predicateWithFormat:@"SELF.sync_timestamp >= %f AND SELF.is_deleted ==NO",timestamp];
    NSArray *feeds = [self getCoreDataObjectsWithEntityName:hFeed andPredicate:predicate];
    if(feeds==nil){
        feeds = [[NSArray alloc] init];
    }
    return feeds;
}

- (void)deleteAllFeeds{
    [self deleteAllOfEntityType:hFeed];
}

//TODO delete this metod before release
- (void)deleteAllPosts{
    [self deleteAllOfEntityType: hPost];
}

- (void)clearDatabase{
    [self deleteAllOfEntityType: hFeed];
    [self deleteAllOfEntityType: hPost];
}

- (void)upadateAddedFeeds:(NSArray*)createdUpdated{
    if(createdUpdated == nil){
        return;
    }
    NSNumber *timestamp = [NSNumber numberWithDouble:[SyncSessionManager getLastSyncTime]];
    for(NSString *url in createdUpdated){
        NSPredicate *predicate = [NSPredicate predicateWithFormat:@"url == [c] %@ ",url];
        NSArray *filteredResults = [self getCoreDataObjectsWithEntityName:hFeed andPredicate:predicate];
        
        NSManagedObjectContext *context = [self managedObjectContext];
        if(filteredResults==nil){
            //MAKE NEW FEED
            Feed *feed = [[Feed alloc] initWithEntity:[NSEntityDescription entityForName:hFeed inManagedObjectContext:context] insertIntoManagedObjectContext:context];
            NSDictionary *feedDictionary = @{@"is_deleted":     [NSNumber numberWithBool:NO],
                                             @"sync_timestamp": timestamp,
                                             @"url":            url};
            [feed updateWithDictionary:feedDictionary];
            NSError *error = nil;
            if([context save:&error]){
                //ok
            }else{
                NSLog(@"CORE DATA MANAGER feed saving error:%@",error);
            }
        }else{
            //UPDATE EXISTING FEED
            Feed *feedToUpdate = filteredResults[0];
            feedToUpdate.sync_timestamp = timestamp;
            feedToUpdate.is_deleted = [NSNumber numberWithBool:NO];
            NSError *error = nil;
            if([context save:&error]){
                //ok
            }else{
                NSLog(@"CORE DATA MANAGER feed updating error:%@",error);
            }
        }
    }
}

- (void)upadateDeletedFeeds:(NSArray*)deleted{
    if(deleted == nil){
        return;
    }
    NSNumber *timestamp = [NSNumber numberWithDouble:[SyncSessionManager getLastSyncTime]];
    for(NSString *url in deleted){
        NSPredicate *predicate = [NSPredicate predicateWithFormat:@"SELF.url == [c] %@ ",url];
        NSArray *filteredResults = [self getCoreDataObjectsWithEntityName:hFeed andPredicate:predicate];
        
        NSManagedObjectContext *context = [self managedObjectContext];
        if(filteredResults==nil){
            //MAKE NEW FEED AND MARK IT AS DELETED
            Feed *feed = [[Feed alloc] initWithEntity:[NSEntityDescription entityForName:hFeed inManagedObjectContext:context] insertIntoManagedObjectContext:context];
            NSDictionary *feedDictionary = @{@"is_deleted":    [NSNumber numberWithBool:YES],
                                             @"sync_timestamp":timestamp,
                                             @"url":           url};
            //?? what about NSSet<Post *> *posts;
            [feed updateWithDictionary:feedDictionary];
            NSError *error = nil;
            if([context save:&error]){
                //ok
            }else{
                NSLog(@"CORE DATA MANAGER feed saving error:%@",error);
            }
        }else{
            //UPDATE EXISTING FEED
            Feed *feedToUpdate = filteredResults[0];
            feedToUpdate.sync_timestamp = timestamp;
            feedToUpdate.is_deleted = [NSNumber numberWithBool:YES];
            NSError *error = nil;
            if([context save:&error]){
                //ok
            }else{
                NSLog(@"CORE DATA MANAGER feed updating error:%@",error);
            }
        }
    }
}

- (BOOL)deleteFeed:(Feed*)feed{
    NSManagedObjectContext *context = [self managedObjectContext];
    NSPredicate *predicate = [NSPredicate predicateWithFormat:@"SELF.url == [c] %@ ",feed.url];
    NSArray *filteredResults = [self getCoreDataObjectsWithEntityName:hFeed andPredicate:predicate];
    //UPDATE EXISTING FEED
    Feed *feedToUpdate = filteredResults[0];
    feedToUpdate.sync_timestamp = [NSNumber numberWithDouble:[feedToUpdate.sync_timestamp doubleValue] +1];//[NSNumber numberWithDouble:([SyncSessionManager getLastSyncTime] +1)];
    feedToUpdate.is_deleted = [NSNumber numberWithBool:YES];
    NSError *error = nil;
    if([context save:&error]){
        //ok
        return YES;
    }else{
        NSLog(@"CORE DATA MANAGER feed updating error:%@",error);
        return NO;
    }
}

- (BOOL)updateFeed: (Feed*)feed withPosts:(NSArray*)posts{
    NSPredicate *p = [NSPredicate predicateWithFormat:@"SELF.url == [c] %@ ",feed.url];
    NSArray *feeds = [self getCoreDataObjectsWithEntityName:hFeed andPredicate:p];
    Feed *feedFromDb;
    if(feeds && feeds.count>0){
        feedFromDb = feeds[0];
        NSMutableArray *postsToAdd = [[NSMutableArray alloc] initWithArray:posts];
        //removing duplicated posts before adding
        for(Post *pToAdd in posts){
            for(Post *pInFeed in [feed.posts allObjects]){
                if([pToAdd isEqualTo:pInFeed]){
                    [postsToAdd removeObject:pToAdd];
                    break;
                }
            }
        }
        if(postsToAdd.count > 0){
            //udpate posts of teh given feed with not duplicated ones
            [feed addPosts: [[NSSet alloc] initWithArray:postsToAdd]];
        }
        [self saveContext];
        return YES;
    }
    return NO;
}

- (Post*)getPostInstance{
    NSManagedObjectContext *context = [self managedObjectContext];
    Post *post = [[Post alloc] initWithEntity:[NSEntityDescription entityForName:hPost inManagedObjectContext:context] insertIntoManagedObjectContext:context];
    return post;
}

- (void)markAsReadNumberOfDays:(int)days{
    //TODO for user
    NSDate *now = [NSDate date];
    NSDate *dayBack = [now dateByAddingTimeInterval:(-60*60*24*days)];
    NSPredicate *p = [NSPredicate predicateWithFormat:@"(pub_date <= %@)",dayBack];
    NSArray *filteredPosts = [self getCoreDataObjectsWithEntityName:hPost andPredicate:p];
    if(filteredPosts){
        NSLog(@"Posts marked as readed: %ld", filteredPosts.count);
        for(Post *p in filteredPosts){
            //zmienia flage tez dla postów w feedach ktore nie są widoczne
            p.is_read = [NSNumber numberWithBool:YES];
        }
    }else{
         NSLog(@"Posts marked as readed: none");
    }
    [self saveContext];
}

- (NSArray*)getAllActivePosts{
    NSMutableArray *array = [[NSMutableArray alloc]init];
    NSArray *activeFeeds = [self getAllActiveFeeds];
    for (Feed *f in activeFeeds){
        if(f.posts ){
            [array addObjectsFromArray:[f.posts allObjects]];
        }
    }
    return array;
}

//TODO syn1
- (NSInteger)getNumberOfUnreadPosts{
    NSInteger counter = 0;
    NSPredicate *predicate = [NSPredicate predicateWithFormat:@"is_read == %@", [NSNumber numberWithBool:NO]];
    NSArray *activeFeeds = [self getAllActiveFeeds];
    for (Feed *f in activeFeeds){
        NSSet *filtered = [f.posts filteredSetUsingPredicate:predicate];
        if(filtered){
            counter+=filtered.count;
        }
    }
    return counter;
}

#pragma mark - private helper methods

- (void)deleteAllOfEntityType:(NSString*)entityType{
    NSManagedObjectContext *context = [self managedObjectContext];
    NSArray *objectsToDelete = [self getCoreDataObjectsWithEntityName:entityType andPredicate:nil];
    for (NSManagedObject *objectToDelete in objectsToDelete) {
        [context deleteObject:objectToDelete];
    }
    NSError *error = nil;
    if([context save:&error]){
        //ok
    }else{
        NSLog(@"CORE DATA MANAGER deleting %@ error:%@",entityType, error);
    }
}

- (NSArray*)getCoreDataObjectsWithEntityName:(NSString*)entName andPredicate:(NSPredicate*)predicate{
    
    NSManagedObjectContext *context = [self managedObjectContext];
    NSEntityDescription *entityDesc = [NSEntityDescription entityForName:entName inManagedObjectContext:context];
    NSFetchRequest *request = [[NSFetchRequest alloc] init];
    //request.resultType = NSDictionaryResultType;
    [request setEntity:entityDesc];
    
    if([entName isEqualToString:hFeed]){
        [request setSortDescriptors:@[[[NSSortDescriptor alloc] initWithKey:@"url" ascending:YES]]];
        [request setRelationshipKeyPathsForPrefetching:@[@"posts"]];
    }
    if(predicate){
        [request setPredicate:predicate];
    }
    [request setReturnsObjectsAsFaults:NO];
    NSError *error = nil;
    NSArray *result =  [context executeFetchRequest:request error:&error];
    
    if(result.count>0){
        if ([entName isEqualToString:hFeed]) {
            Feed *feed = (Feed*)result[0];
            if(feed.posts){
                NSLog(@"POSTS count: %d",(int)feed.posts.count);
            }
        }
        return (NSArray*)result;
    }else{
        return nil;
    }
    
}

@end
